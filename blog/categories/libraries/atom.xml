<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Libraries | Fragmented Memory]]></title>
  <link href="http://www.fragmentedmemory.com/blog/categories/libraries/atom.xml" rel="self"/>
  <link href="http://www.fragmentedmemory.com/"/>
  <updated>2013-06-23T17:13:57+01:00</updated>
  <id>http://www.fragmentedmemory.com/</id>
  <author>
    <name><![CDATA[Garry Bodsworth]]></name>
    <email><![CDATA[blog@fragmentedmemory.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Writing A Decent Library]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/10/29/writing-decent-library/"/>
    <updated>2007-10-29T20:58:00+00:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/10/29/writing-decent-library</id>
    <content type="html"><![CDATA[<div class='post'>
When you are writing a shared library (DLL) you have to put a lot of thought into the public interface which your customer (another programmer) will be using.<br /><br />What you have to work out is whether it is closed or open source, whether the binaries are supplied, and how you keep the user from having broken interfaces on different versions.  All of this is from the point of view from a C++ programmer.<br /><br />I think it is best to start with how not to write a closed-source library:<br />* Do not use templates.<br />* Do not have implementation half in the binary and half in the headers.<br />* Do not expose the innards of your program.<br /><br />When creating a closed-source library you have to firewall the innards (which are probably commercially sensitive) from the interface.  This would mean some use of the <a href="http://c2.com/cgi/wiki?PimplIdiom">Pimpl Idiom</a>.<br /><br />You need to use solidly defined types like if you were binding to another language like Python.  This means that the implementation can live in the binary and the interface is defined in your headers.<br /><br />One of the problems it is easy to encounter is when STL is exposed in the library.  The problem occurs when people use different implementations of the standard library which means you either need to maintain versions for that particular setup.<br /><br />By making those two decisions you can massively simplify the maintenance and the headaches of people trying to implement it.  You have to think carefully about the simplest interface for the developers who have to work out how to integrate it.<br /><br />By not exposing the innards of the library you can also protect yourself from problems when the library loads/unloads because you can't have conflicting CRTs/libraries.<br /><br />I suppose what I am suggesting is to have the most simple public interface and make sure that all implementation is hidden away.  Almost only using a C interface for a library means you don't encounter the problems where you have to think about supplying a version for each version of the compiler your users have.</div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>John Torjo</div>
<div class='content'>
There's a very nice article I recently read:<BR/><BR/><A HREF="http://www.artima.com/cppsource/type_erasure.html" REL="nofollow">http://www.artima.com/cppsource/type_erasure.html</A><BR/><BR/>Best,<BR/>John</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Intel Open-Sources Threading Bulding Blocks]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/07/25/intel-open-sources-threading-bulding/"/>
    <updated>2007-07-25T21:44:00+01:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/07/25/intel-open-sources-threading-bulding</id>
    <content type="html"><![CDATA[<div class='post'>
Intel has just <a href="http://threadingbuildingblocks.org/">open-sourced their Threading Building Blocks library</a>.  Intel describe it as a "rich and complete approach to expressing parallelism in a C++ program".<br /><br />With multi-threading in general being so immature when looking at other libraries, another solution can never hurt.  So add it to Boost.Threads, OpenMP, wxThread and the myriad of others.  Admittedly the way that all of the alternatives work is very low-level and means very careful design is required.<br /><br />I'm interested to see the approach of the library to multi-threading as it looks quite complicated to wrap your head around.  The best bit though is there is apparently a cache aligned memory allocator as part of it that can be used independently.<br /><br />There is a Slashdot article about it <a href="http://developers.slashdot.org/developers/07/07/25/1324221.shtml">here</a>.  Also a bog post <a href="http://softwareblogs.intel.com/2006/12/18/threading-building-blocks-solution-looking-for-a-problem/">here</a> looks interesting covering the subject.<br /><br />All I can say is let battle commence and lets see what multi-threading packages are left standing ;)</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Boost 1.34 Released]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/05/18/boost-134-released/"/>
    <updated>2007-05-18T21:45:00+01:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/05/18/boost-134-released</id>
    <content type="html"><![CDATA[<div class='post'>
The latest version of the <a href="http://www.boost.org">Boost</a> Library has been released.  This is version 1.34 and you can read the changes on the <a href="http://www.boost.org/">Boost frontpage</a>.<br /><br />Boost is a fantastic peer reviewed library collection for C++.  It adds power and robustness for C++ programmers, after all we shouldn't need to reinvent the wheel all of the time.<br /><br />There are five new libraries:<br />     * Foreach Library:<br />         BOOST_FOREACH macro for easily iterating over the elements of a<br />         sequence, from Eric Niebler.<br />     * Statechart Library:<br />         Arbitrarily complex finite state machines can be implemented in<br />         easily readable and maintainable C++ code, from Andreas Huber.<br />     * TR1 Library:<br />         An implementation of the C++ Technical Report on Standard Library<br />         Extensions, from John Maddock.<br />         This library does not itself implement the TR1 components, rather<br />         it's a thin wrapper that will include your standard library's TR1<br />         implementation (if it has one), otherwise it will include the Boost<br />         Library equivalents, and import them into namespace std::tr1. Highlights<br />         include: Reference Wrappers, Smart Pointers, result_of,<br />         Function Object Binders, Polymorphic function wrappers, Type Traits,<br />         Random Number Generators and Distributions, Tuples, Fixed Size Array,<br />         Hash Function Objects, Regular Expressions and<br />         Complex Number Additional Algorithms.<br />     * Typeof Library:<br />         Typeof operator emulation, from Arkadiy Vertleyb and Peder Holt.<br />     * Xpressive Library:<br />         Regular expressions that can be written as strings or as expression<br />         templates, and that can refer to each other and themselves recursively<br />         with the power of context-free grammars, from Eric Niebler. <br /><br />Obviously lots of the other libraries have been updated like Boost::Python.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Crystal Space 1.0 Released]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/01/19/crystal-space-10-released/"/>
    <updated>2007-01-19T20:35:00+00:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/01/19/crystal-space-10-released</id>
    <content type="html"><![CDATA[<div class='post'>
Back in the olden days when I was at university I remember one of the projects I had a play with was <a href="http://www.crystalspace3d.org/main/Main_Page">Crystal Space</a>.  I think I discovered it through the old <a href="http://cg.cs.tu-berlin.de/~ki/engines.html">3D Engines List</a>.<br /><br />Finally after ten years <a href="http://www.crystalspace3d.org/main/Crystal_Space_1.0_and_New_Site">version 1.0 of the Crystal Space library has been released</a>.  It's great to this see this finally happen as it has been so close for so long (in fat it was pretty usable not long into its development).  One of my favourite technologies it has is <a href="http://en.wikipedia.org/wiki/Portal_(computer_graphics)">Portal Rendering</a>, this was added because the original version of <a href="http://www.3drealms.com/">Prey</a> (before it got canned and eventually released recently).  At the time it was going to be revolutionary, but I think that style of rendering can produce some cool and crazy effects.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[GUI Toolkits - XULRunner platform]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2006/11/15/gui-toolkits-xulrunner-platform/"/>
    <updated>2006-11-15T15:05:00+00:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2006/11/15/gui-toolkits-xulrunner-platform</id>
    <content type="html"><![CDATA[<div class='post'>
You can't have escaped this platform, you might not have heard about it, but it provides the basis for <a href="http://www.getfirefox.com">Firefox</a>, <a href="http://www.mozilla.com/en-US/thunderbird/">Thunderbird</a>, <a href="http://www.getdemocracy.com/">Democracy Player</a>, and <a href="http://www.songbirdnest.com/">SongBird</a> (which I mentioned <a href="http://garrys-brain.blogspot.com/2006/10/digital-music-songbird.html">before</a> and it's continuing apace).  A good place to start is the <a href="http://en.wikipedia.org/wiki/XULRunner">Wikipedia article on XULRunner</a>, it provides the links you need to get started.<br /><br />XULRunner is not simply a user interface but probably could be described as a platform like Microsoft's <a href="http://en.wikipedia.org/wiki/Extensible_Application_Markup_Language">XAML/.NET</a> or like <a href="http://www.java.net/">Java's virtual machine</a> (very loosely) or <a href="http://dev.aol.com/boxely/">Boxely from AOL</a>.  Essentially it provides a layer of abstraction from the underlying architecture in order to allow the developer to work on the actual coding.  XULRunner is the framework to allow standalone applications to be developed using the XUL language used for Firefox extensions.<br /><br />Currently <a href="http://developer.mozilla.org/en/docs/XULRunner">XULRunner</a> is in beta with version 1.8, but with version 1.9 next year they recommend that for production releases.  Along with the 1.9 release the Gecko rendering engine is also getting updated with some additional nice vector rendering.<br /><br />The framework provides a myriad of features.  There is built-in spell-checking, networking, the aforementioned Gecko engine, web services, storage/SQLie interfaces, UI, the ability to embed in another application, and also the Python bindings (full version forthcoming).  I think the reason that I find this quite interesting is the two applications I have used most at home and work in the past couple of years have been based on this.  I just wonder how far it can all be pushed for heavyweight desktop application development.<br /><br />You can view a list of applications based on XULRunner <a href="http://developer.mozilla.org/en/docs/XULRunner_Hall_of_Fame">here</a>.  When the final proper release of 1.9 is out I imagine there will be more people willing to use it as it won't be all belt and braces, there can be solid tutorials and the suchlike.<br /><br />With so many of these types of projects around at the moment, I am wondering when the "survival of the fittest" will start to kick in.  Admittedly, XULRunner has a very strong chance since it is a platform for Thunderbird and Firefox.</div>

]]></content>
  </entry>
  
</feed>
