<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Visual Studio 2005 | Fragmented Memory]]></title>
  <link href="http://www.fragmentedmemory.com/blog/categories/visual-studio-2005/atom.xml" rel="self"/>
  <link href="http://www.fragmentedmemory.com/"/>
  <updated>2013-06-23T17:13:57+01:00</updated>
  <id>http://www.fragmentedmemory.com/</id>
  <author>
    <name><![CDATA[Garry Bodsworth]]></name>
    <email><![CDATA[blog@fragmentedmemory.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[STLPort Visual Studio 2005 Visualisers - autoexp.dat]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/12/13/stlport-visual-studio-2005-visualisers/"/>
    <updated>2007-12-13T21:23:00+00:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/12/13/stlport-visual-studio-2005-visualisers</id>
    <content type="html"><![CDATA[<div class='post'>
Thanks to a comment on one of the posts about autoexp.dat and STLPort where I did a bit of a ham-fisted attempt at creating visualisers for STL containers in the Visual Studio 2005 debugger, I have been informed that there is a much better (and more comprehensive) version than my hack.<br /><br />Now as part of the upcoming version 5.2 of STLPort there is a comprehensive and well written set of visualisers.  This means debugging is now on parity with the in-built Microsoft containers.  The version linked to in this post is for 5.2 but does work well with 5.1.<br /><br />You can get the <a href="http://stlport.svn.sourceforge.net/viewvc/stlport/trunk/STLport/etc/autoexp.dat?revision=HEAD">autoexp.dat edits here</a>.  It points to the Subversion repository head version.  Since it will be part of the distribution it should be maintained and provides another excellent reason for using it (as well as the performance).<br /><br />If anyone is using my hack then please use this version from the good people at STLPort - it is much better!<br /><br />I suppose now it would be nice to have something similar for Boost...</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Studio 2005 Intellisense Update]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/11/13/visual-studio-2005-intellisense-update/"/>
    <updated>2007-11-13T22:29:00+00:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/11/13/visual-studio-2005-intellisense-update</id>
    <content type="html"><![CDATA[<div class='post'>
Ah, Intellisense, the bane of all C++ developers.  I can't tell you how many times my Visual Studio has crawled into a hole and refused to get out or how many times the ncb has been corrupted by some arcane behaviour.<br /><br />But rather than waiting for Visual Studio 2008 for some improvements the Visual Studio team have been good enough to release an interim patch.  You can read about it <a href="http://blogs.msdn.com/vcblog/archive/2007/11/12/performance-improvements-in-visual-c.aspx">here</a>.<br /><br />Hopefully this will make some developer's lives easier.  You can download the patch from <a href="http://connect.microsoft.com/VisualStudio/Downloads/DownloadDetails.aspx?DownloadID=9436">this link</a>.</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Useful Tools For VS2005]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/09/27/useful-tool-for-vs2005/"/>
    <updated>2007-09-27T22:29:00+01:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/09/27/useful-tool-for-vs2005</id>
    <content type="html"><![CDATA[<div class='post'>
Visual Studio 2005 provides a very decent IDE to work with (if you overlook the crashing and disappearing into black holes).  There hasn't been much focus on the native C++ side of the IDE for a while, which means it does lack some useful features.<br /><br />One of those tools available for free on the internet is <a href="http://www.cupla.net/CodeWiz2/">CodeWiz2</a> providing a number of very quick and simple additions to the IDE which makes coding a bit easier.  Friend File lets you switch between header and implementation and Friend Member lets you switch between declaration and definition for a single function.  I did have a script that did it, but this works much better (and will at least work on Vista as well since the Macro Explorer was broken last time I tried).<br /><br />It is also scriptable in a manner of speaking meaning you can get common code structures or comments at the tap of a button.  Oh yeah, did I mention it is free?<br /><br />Another free tool available for Visual C++ is <a href="http://www.devexpress.com/Products/NET/IDETools/RefactorCPP/">Refactor!</a> which you will be surprised to hear offers refactoring for C++.  Only the simplest functionality is available in the free version but it is quite interesting.  I tend to refactor by hand myself, but one useful side-effect of this plug-in is when it highlights all instances of a variable which helps make the code a bit easier to navigate (and should really be a basic feature of the IDE).</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Visual Studio 2005 autoexp.dat for STLPort debugging]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/08/30/visual-studio-2005-autoexpdat-for/"/>
    <updated>2007-08-30T22:44:00+01:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/08/30/visual-studio-2005-autoexpdat-for</id>
    <content type="html"><![CDATA[<div class='post'>
From the contents of <a href="http://garrys-brain.blogspot.com/2007/08/debugging-stlport-in-visual-studio.html">my previous post</a> I have created an autoexp.dat for download (Visual Studio 2005 only).  <a href="http://garry.bodsworth.googlepages.com/autoexp.zip">You can get it here</a>.<br /><br />Simply copy the extracted file into <span style="font-weight:bold;">C:\Program Files\Microsoft Visual Studio 8\Common7\Packages\Debugger</span><br /><br />Visual Studio 2008 will work if you follow the instructions in my previous post but the autoexp.dat is a bit different between versions.</div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Garry Bodsworth</div>
<div class='content'>
I am using 5.1.3.  I haven't looked at 5.1.4 yet, but I didn't think the release notes suggested anything major.<BR/><BR/>I know that certainly with older versions it is completely different because of the use of the "priv" namespace.<BR/><BR/>Garry</div>
</div>
<div class='comment'>
<div class='author'>jean-gab</div>
<div class='content'>
This used to work for me until I upgraded to 5.1.4. Can you please tell me which version of STLport you're running?<BR/><BR/>Thanks!</div>
</div>
<div class='comment'>
<div class='author'>Garry Bodsworth</div>
<div class='content'>
Glad you have found it useful.  The map took quite a lot of tweaking to make it work on the code I had written to test it.<BR/><BR/>The STLPort map item pointers seem to be a pair{T1, T2} but it is cast to one pointer.<BR/><BR/>The good thing about this ability to visualise means the only reason to switch to the Microsoft STL is gone ;)</div>
</div>
<div class='comment'>
<div class='author'>Kevin</div>
<div class='content'>
This post was very useful to me. I was considering using the Microsoft STL during debug so that I would have the visualizers available. Now I won't have to suffer through that! Unfortunately, I was unable to get the map visualizer to work properly, but I am sure that with some tinkering that will be resolved.</div>
</div>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Debugging STLPort in Visual Studio - autoexp.dat]]></title>
    <link href="http://www.fragmentedmemory.com/blog/2007/08/30/debugging-stlport-in-visual-studio/"/>
    <updated>2007-08-30T22:28:00+01:00</updated>
    <id>http://www.fragmentedmemory.com/blog/2007/08/30/debugging-stlport-in-visual-studio</id>
    <content type="html"><![CDATA[<div class='post'>
We use <a href="http://stlport.sourceforge.net/">STLPort</a> for our C++ standard library as it is substantially faster than the one supplied with Visual Studio 2005.  I  have expended quite a lot of energy trying to get the Microsoft STL to speed up more, with custom allocators and the suchlike.  The reason I pursued it was to make debugging easier as there was no way (by default) to look inside the containers in a structured fashion.<br /><br />Then I realised I was approaching the problem from the wrong angle.  Perhaps Visual Studio allows us to customise the debugging visualisations, and that means using STLPort with all the debugging benefits of the in-built system.  This was where I discovered the <a href="http://www.developer.com/net/cplus/article.php/3509761">autoexp.dat</a> which is more or less undocumented by Microsoft.  The system allows you to create custom visualisers for any datatype in the debugger.  Unfortunately it requires arcane rituals to make it work and I believe the format may have changed for VS2005.<br /><br />Anyway on to the meat of this post!  I will post here the code you need to visualise map, vector, set, and list in Visual Studio 2005.  First go and open <span style="font-weight:bold;">C:\Program Files\Microsoft Visual Studio 8\Common7\Packages\Debugger\autoexp.dat</span> in a text editor.  Locate the line featuring the text <span style="font-weight:bold;">PROPVARIANT</span>.  Just above that line add the following:<br /><pre><br />;------------------------------------------------------------------------------<br />;  STLPORT visualisers<br />;------------------------------------------------------------------------------<br /><br />;------------------------------------------------------------------------------<br /><br />;  stlp_std::vector<br />;------------------------------------------------------------------------------<br />stlp_std::vector<*>{<br />    children<br />    (<br />        #array<br />        (<br />            expr :    ($c._M_start)[$i], <br /><br />            size :    $c._M_finish-$c._M_start<br />        )<br />    )<br />   <br />    preview<br />    (<br />        #(<br />            "[",<br />            $e._M_finish - $e._M_start ,<br />            "](",<br /><br />           <br />            #array<br />            (<br />                expr :     ($c._M_start)[$i], <br />                size :     $c._M_finish-$c._M_start<br />            ),<br />            ")"<br />        )<br /><br />    )<br />}<br /><br />;------------------------------------------------------------------------------<br />;  stlp_std::list<br />;------------------------------------------------------------------------------<br />stlp_std::list<*,*>{<br /><br />    children<br />    (<br />        #list<br />        (<br />         head : $c._M_node._M_data._M_next,<br />         skip : &($c._M_node._M_data),<br />         next : _M_next<br />        ) : #( *($T1 *)(sizeof(stlp_std::priv::_List_node_base)+((char*)&($e))) )<br /><br />    )<br />   <br />    preview<br />    (<br />     #(<br />      "(",<br />      #list<br />      (<br />       head : $c._M_node._M_data._M_next,<br />       skip : &($c._M_node._M_data),<br />       next : _M_next<br />      ) : *($T1 *)(sizeof(stlp_std::priv::_List_node_base)+((char*)&($e))),<br /><br />      ")"<br />     )<br />    )<br />}<br /><br />;------------------------------------------------------------------------------<br />;  stlp_std::set<br />;------------------------------------------------------------------------------<br /><br />stlp_std::set<*> {<br /> children<br /> (<br />  #tree<br />  (<br />   head : $c._M_t._M_header._M_data._M_parent,<br />   skip : $c._M_t._M_header._M_data,<br />   left : _M_left,<br />   right : _M_right,<br />   size : $c._M_t._M_node_count<br /><br />  ) : ((_Node*)(&$e))->_M_value_field<br /> )<br />}<br /><br />;------------------------------------------------------------------------------<br />;  stlp_std::map<br />;------------------------------------------------------------------------------<br /><br />stlp_std::map<*,*,*,*> {<br /> children<br /> (<br />  #(<br />   [map]: [$c,!],<br /><br />   #tree<br />   (<br />    head : $c._M_t._M_header._M_data._M_parent,<br />    left : _M_left,<br />    right : _M_right,<br />    skip : $c._M_t._M_header._M_data<br /><br />   ) : *(stlp_std::pair<$T1,$T2>*)(((char*)(&((*((stlp_std::priv::_Rb_tree_node<$T1>*)(&$e)))._M_value_field))))<br />  )<br /> )<br />}<br /></pre><br /><br />I am pretty sure I need to do some more tweaking to get it working even better.  The map implementation is certainly the best part as it displays the list of items as pairs of (key, value) which is really useful.  Some of the code for this was pilfered from the comments of <a href="http://www.virtualdub.org/blog/pivot/entry.php?id=120">this article</a> - thanks to those people who blazed the initial trail.</div>


<h2>Comments</h2>


<div class='comments'>
<div class='comment'>
<div class='author'>Leviana</div>
<div class='content'>
Can I apply debugging on my <a href="http://www.rxsexual.com/" rel="nofollow">Buy Generic Viagra</a> blog ?</div>
</div>
<div class='comment'>
<div class='author'>Zahary Karadjov</div>
<div class='content'>
A more complete set of visualizers is  now available at:<BR/>http://stlport.svn.sourceforge.net/viewvc/stlport/trunk/STLport/etc/autoexp.dat?revision=HEAD</div>
</div>
<div class='comment'>
<div class='author'>Laurent</div>
<div class='content'>
I was using your file as a starting point, trying to improve it for other types. My Stlport setup is different than yours, it does not as use a stlp_std::priv:: namespace.  <BR/>Note that the STLPort namespace can be one of stlpdmtx_std, stlpd_std, stlpdxmtx_std, stlpdx_std too.<BR/><BR/><BR/>Maybe my setup is wrong, I am still using VS2005 without the SP1 and my STLPort is quite outdated (5.0.2). I will upgrade this week and see if things goes better. <BR/><BR/><BR/>In case you need it, this is my test file:<BR/><BR/>#include &lt;map&gt;<BR/>#include &lt;set&gt;<BR/>#include &lt;list&gt;<BR/>#include &lt;vector&gt;<BR/>#include &lt;string&gt;<BR/><BR/>using namespace std;<BR/><BR/>int main(){<BR/><BR/> _Rb_tree_node&lt;int&gt; rb_t_n_int;<BR/> rb_t_n_int._M_value_field = 4;<BR/> _Rb_tree_node&lt;string&gt; rb_t_n_string;<BR/> rb_t_n_string._M_value_field = "four";<BR/><BR/> string s("some string");<BR/><BR/> pair&lt;int, int &gt; pii;<BR/> pair&lt;int, string &gt; pis;<BR/> pair&lt;string, string &gt; pss;<BR/> pair&lt;string, int &gt; psi;<BR/><BR/> map&lt;int, int &gt; mii;<BR/> map&lt;int, string &gt; mis;<BR/> map&lt;string, string &gt; mss;<BR/> map&lt;string, int &gt; msi;<BR/> map&lt;double, double&gt; mdd;<BR/> set&lt;int&gt; si;<BR/> set&lt;string&gt; ss;<BR/> list&lt;int&gt; li;<BR/> list&lt;string&gt; ls;<BR/> vector&lt;int&gt; vi;<BR/> vector&lt;string&gt; vs;<BR/><BR/> vector&lt;vector&lt;string&gt; &gt; v_vs;<BR/> map&lt;string, vector&lt;string&gt; &gt; ms_vs;<BR/><BR/> set&lt; vector&lt;int&gt; &gt; s_vi;<BR/> set&lt; vector&lt;string&gt; &gt; s_vs;<BR/><BR/> pii.first = 1;<BR/> pii.second = 2;<BR/> pis.first = 1;<BR/> pis.second = "two";<BR/> pss.first = "one";<BR/> pss.second = "two";<BR/> psi.first = "one";<BR/> psi.second = 2;<BR/><BR/> mii.insert(make_pair(1, 10));<BR/> mii.insert(make_pair(2, 20));<BR/> mii.insert(make_pair(3, 30));<BR/> mii.insert(make_pair(4, 40));<BR/> <BR/> mis.insert(make_pair(1, "one"));<BR/> mis.insert(make_pair(2, "two"));<BR/> mis.insert(make_pair(3, "three"));<BR/> mis.insert(make_pair(4, "four"));<BR/> <BR/> mss.insert(make_pair("one", "one"));<BR/> mss.insert(make_pair("two", "two"));<BR/> mss.insert(make_pair("three", "three"));<BR/> mss.insert(make_pair("four", "four"));<BR/><BR/> msi.insert(make_pair("one", 1));<BR/> msi.insert(make_pair("two", 2));<BR/> msi.insert(make_pair("three", 3));<BR/> msi.insert(make_pair("four", 4));<BR/><BR/> mdd.insert(make_pair(1.1, 11.1));<BR/> mdd.insert(make_pair(2.2, 22.2));<BR/> mdd.insert(make_pair(3.3, 33.3));<BR/> mdd.insert(make_pair(4.4, 44.4));<BR/><BR/> si.insert(1);<BR/> si.insert(2);<BR/> si.insert(3);<BR/> si.insert(4);<BR/><BR/> ss.insert("one");<BR/> ss.insert("two");<BR/> ss.insert("three");<BR/> ss.insert("four");<BR/><BR/> li.push_back(1);<BR/> li.push_back(2);<BR/> li.push_back(3);<BR/> li.push_back(4);<BR/><BR/> ls.push_back("one");<BR/> ls.push_back("two");<BR/> ls.push_back("three");<BR/> ls.push_back("four");<BR/><BR/> vi.push_back(1);<BR/> vi.push_back(2);<BR/> vi.push_back(3);<BR/> vi.push_back(4);<BR/><BR/> vs.push_back("one");<BR/> vs.push_back("two");<BR/> vs.push_back("three");<BR/> vs.push_back("four");<BR/><BR/> v_vs.push_back(vs);<BR/> v_vs.resize(2);<BR/> v_vs[1].push_back("one");<BR/> v_vs[1].push_back("two");<BR/> v_vs[1].push_back("three");<BR/> v_vs[1].push_back("four");<BR/><BR/> ms_vs.insert(make_pair("fr", vs));<BR/> ms_vs.insert(make_pair("en", v_vs[1]));<BR/><BR/> s_vi.insert(vi);<BR/> s_vs.insert(vs);<BR/>}</div>
</div>
<div class='comment'>
<div class='author'>Garry Bodsworth</div>
<div class='content'>
I misinterpreted what you said.  The one I supplied only works for you with map{int, int} right?<BR/><BR/>That is odd because I have had maps of complex types to complex types visualise in list form with this visualiser.  I'll have a closer look at it over the next week.</div>
</div>
<div class='comment'>
<div class='author'>Garry Bodsworth</div>
<div class='content'>
I started with an ugly hack like that before using the map implementation in the post above.  Does my implementation work for you.<BR/><BR/>The solution really came down to understanding what STLPort was doing with its pointers and then interpreting those into the proper structures/classes by casting.<BR/><BR/>You can copy and paste my implementation above in, it looks like it is truncated but all of the text for the visualiser is on the page.</div>
</div>
<div class='comment'>
<div class='author'>Laurent</div>
<div class='content'>
My map visualizer looks like this, but it doesn't work for every container:<BR/> map&lt;string,int&gt; or map&lt;int,int&gt; is ok but <BR/><BR/>map&lt;int, string&gt; or map&lt;string,string&gt; is not! <BR/><BR/>Any idea ?<BR/><BR/>stlp_std::map&lt;*,*,*,*&gt; {<BR/> children<BR/> (<BR/>  #(<BR/>   [map]: [$c,!],<BR/>   #tree<BR/>   (<BR/>    head : $c._M_t._M_header._M_data._M_parent,<BR/>    left : _M_left,<BR/>    right : _M_right,<BR/>    skip : $c._M_t._M_header._M_data<BR/><BR/>   ) : #( *(stlp_std::pair&lt;$T1,$T2&gt; *)(sizeof(stlp_std::_Rb_tree_node_base)+((char*)&($e))) ) ; this is an ugly hack that works for ( map&lt;string,int&gt;, map&lt;int,int&gt;, map&lt;double,double&gt; ) but not for map&lt;int,string&gt;, map&lt;string,string&gt; ... )<BR/> ;  : *(stlp_std::pair&lt;$T1,$T2&gt;*)(((char*)(&((*((stlp_std::_Rb_tree_node&lt;$T1&gt;*)(&$e)))._M_value_field))))  ;   works only for map&lt;int,int&gt;<BR/>  )<BR/> )</div>
</div>
</div>

]]></content>
  </entry>
  
</feed>
